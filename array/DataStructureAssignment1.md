# I. 다항식의 곱셈과 덧셈

## 1. 방식 1(모든 차수의 계수를 저장)을 활용한 다항식의 덧셈과 곱셈**

### 1) 수식의 입력 : main( )

- 다항식의 차수와 계수배열로 이루어진 구조체를 선언한다.
- 과제의 요구사항에서 최대 차수가 5이므로 입력받는 항은 6개가 되어야 한다.
- 띄어쓰기 포함 12개를 입력받으므로 a\_input[12]와 b\_input[12]를 선언한다.
- 각 수식의 항의 개수를 저장하는 a\_len, b\_len을 선언한다.
- input에 저장된 데이터를 strtok을 활용하여 공백을 기준으로 분할하고 각 구조체에 저장하며, 각 수식의 항의 개수를 최신화한다.
- 이 때 항의 개수가 6개를 초과하면 에러를 발생시켜 프로그램을 종료한다. 

### 2) 수식의 덧셈 : polynominal poly\_add1(polynominal A, polynominal B)

- 결과 다항식 구조체와 각 구조체의 계수 배열을 가리키는 인덱스 변수 Apos, Bpos, Cpos를 선언한다.
- 각 다항식의 덧셈은 가장 앞쪽에 위치한 각 항의 지수를 비교함에 따라 진행된다.
- 첫째, 각 항의 지수가 다를 경우 더 큰 지수의 계수 값을 결과 다항식에 저장하고, 해당 수식의 인덱스를 후순위로 바꾼다.
- 둘째, 각 항의 지수가 같을 경우 해당 항의 계수를 모두 더한 값을 결과 다항식에 저장하고, 두 수식의 인덱스를 후순위로 바꾼다.
- 이러한 과정을 각 수식의 인덱스가 가장 마지막 항에 도달할 때 까지 반복한다. 


### 3) 수식의 곱셈 : polynominal poly\_mul1(polynominal A, polynominal B)

- 결과 다항식 구조체와 임시계수, 임시지수, 결과다항식의 최대 차수, 카운트 변수를 선언한다.
- 각 다항식의 곱셈은 첫번째 항부터 순서대로 각 항을 서로 한번씩 곱한 값을 저장함에 따라 진행된다.
- 각 항의 계수를 서로 곱하여 임시 계수를 계산하고, 각 항의 지수를 서로 더하여 임시 지수를 계산한다.
- 이 값의 지수에 해당하는 위치에 결과 다항식의 계수 값을 저장한다.
- 단, 각 항을 모두 곱하면 지수가 중복되는 경우가 생길 수 있으므로 이를 고려해야 한다.
- 임시계수 값을 저장할 때 이미 해당 지수에 값이 존재하여 겹치는 경우에 카운트를 증가시킨다. 
- 더불어 특정 수식에 계수가 0인 항을 추가하는 경우를 고려해야 한다.
- 이 경우 전체 연산 횟수에서 제외해야 하므로 카운트를 증가시킨다.
- 3x3 + 0x2 + 6x + 3과 7x2  + 5x + 1을 곱하는 경우 총 12번의 연산이 일어나며 카운트가 증가되는 경우는 다음과 같다. 
- 21x5 + 15x4 + 3x3 + **(0x4) + (0x3) + (0x2) + (42x3)** + 30x2 + 6x + **(21x2) + (15x)** + 3 
- 이를 기반으로 결과다항식의 차수를 계산하며 이는 전체 연산 횟수에서 중복 값과 0차항을 제거한 값이다. 
- 예) 12(연산횟수) – 6(count) – 1(0차항) = 5차항


### 4) 수식의 출력 : main( )

- 0차항을 제외한 다차항을 반복을 활용해 x^와 +를 추가하여 출력한다.
- 이 때 지수는 결과다항식의 차수를 복사한 변수 c1\_len, c2\_len을 1씩 감소시키며 출력한다.
- 각 결과다항식의 계수 배열의 마지막 값인 0차항을 출력한다. 


### 5) 수식의 값 계산 : main( )

- 입력 받은 값에 따라 특정 수식을 선택하고, 값을 대입하여 값을 산출한다.
- 이 때 switch문을 활용한다.
- 수식의 지수 계산은 <math.h>의 pow()함수를 활용하여 계산한다. 


### 6) 실행결과 

- 강의자료에 나온 수식 값을 기반으로 테스트 한 결과
- 이 외에 다양한 경우의 수(음수계수 등)을 테스트 한 결과 문제 없이 출력되었음
- \<img width="487" alt="Aspose Words 5d0761ac-de24-41a2-a695-086c205cbd2e 004" src="https://user-images.githubusercontent.com/63644587/116426507-1ebd4c00-a87e-11eb-9502-62eb2c477c4f.png">
!<img width="487" alt="Aspose Words 5d0761ac-de24-41a2-a695-086c205cbd2e 003" src="https://user-images.githubusercontent.com/63644587/116426501-1d8c1f00-a87e-11eb-98b2-7fd247be0ef6.png">
[Uploading Aspose.Words.5d0761ac-de24-41a2-a695-086c205cbd2e.002.png…]()


## 2. 방식 1(0이 아닌 계수의 차수만 저장)을 활용한 다항식의 덧셈과 곱셈


### 1) 수식의 입력 : main( ) 

- 다항식의 차수와 계수로 이루어진 구조체 배열을 전역변수로 선언한다.
- 하나의 배열에서 수식 1, 2, 3(덧셈), 4(곱셈)을 저장하므로 각 수식의 시작과 끝을 지정해주는 변수를 선언한다.
- 과제의 요구사항에서 최대 차수가 5이므로 입력받는 항은 6개가 되어야 한다.
- 띄어쓰기 포함 12개를 입력받으므로 a\_input[12]와 b\_input[12]를 선언한다.
- input에 저장된 데이터를 strtok을 활용하여 공백을 기준으로 분할하고 각 구조체 배열에 저장한다. 이 때 계수와 차수를 동시에 입력 받으므로 flag 변수를 만들어 구분해 저장한다. 더불어 idx 변수를 통해 각 배열에 접근함과 동시에 수식 별 항의 개수를 저장한다.
- 이 때 항의 개수가 6개를 초과하면 에러를 발생시켜 프로그램을 종료한다. 
- 데이터를 넣은 후 항의 개수를 고려하여 각 수식의 시작과 끝, 다음 수식의 시작을 의미하는 avail을 조정한다.



### 2) 수식의 덧셈 : void poly\_add2(int As, int Ae, int Bs, int Be, int \*Cs, int \*Ce)

- 다항식 3의 추가가 시작되므로 Cs값을 avail 값으로 지정해준다.
- 각 다항식의 덧셈은 가장 앞쪽에 위치한 각 항의 지수를 비교함에 따라 진행된다.
- Compare( ) 함수를 활용하여 각 항의 지수를 비교한 결과를 >, =, <로 반환한다.
- Switch 문을 활용하여 반환 값에 따른 연산을 시행한다.
- 각 항의 지수가 다를 경우 더 큰 지수의 계수 값을 결과 다항식에 저장하고, 해당 수식의 시작 인덱스를 후순위로 바꾼다.
- 각 항의 지수가 같을 경우 해당 항의 계수를 모두 더한 값을 결과 다항식에 저장하고, 두 수식의 시작 인덱스를 후순위로 바꾼다.
- 저장 시에는 attach( ) 함수를 활용해 계수와 지수를 저장하고, avail 값을 증가시킨다.
- 이러한 과정을 각 수식의 시작 인덱스가 종료 인덱스에 도달할 때 까지 반복한다.
- 각 수식에 남아있는 항들을 결과 다항식에 추가한다.
- 다항식 3의 추가가 완료되었으므로 Ce 값을 avail -1로 지정해준다. 


### 3) 수식의 곱셈 : void poly\_mul2(int As, int Ae, int Bs, int Be, int \*Ds, int \*De)

- 다항식 4의 추가가 시작되므로 Ds값을 avail 값으로 지정해준다.
- 각 다항식의 곱셈은 첫번째 항부터 순서대로 각 항을 서로 한번씩 곱한 값을 저장함에 따라 진행된다.
- 각 항의 계수를 서로 곱하여 임시 계수를 계산하고, 각 항의 지수를 서로 더하여 임시 지수를 계산한다.
- 첫 곱셈의 경우 D의 시작위치에 추가한다.
- 이후의 곱셈의 경우 임시지수를 바탕으로 새로운 값이 추가될 위치와 추가방식을 is\_exist( ) 함수를 통해 반환 받는다. 
  - 이진탐색을 통해 D에서 해당 지수가 있는지 확인한다.
  - 있는 경우 해당 지수에 계수 값을 더해야하며(flag =0), 그곳의 위치를 반환한다.
  - 없는 경우에는 중간에 새로운 지수를 추가하거나 맨 뒤에 추가해야한다.
  - (flag = 1)과 추가해야할 위치를 반환한다.
- 반환 값에 따라 임시지수와 임시계수를 D에 추가한다. 이 때 중간에 끼워넣는 경우 memmove를 사용하여 메모리를 한칸씩 뒤로 이동시킨 후 값을 추가한다.


### 4) 수식의 출력 : void print\_poly(int s, int e)

- 해당 수식의 시작과 끝을 받아 0차항을 제외한 다차항을 x^와 +를 추가하여 출력한다.
- 이후 다항식의 계수 배열의 마지막 값인 0차항을 출력한다. 


### 5) 수식의 값 계산 : main( )

- 입력 받은 값에 따라 특정 수식을 선택하고, 값을 대입하여 값을 산출한다.
- 이 때 switch문을 활용한다.
- 수식의 지수 계산은 <math.h>의 pow()함수를 활용하여 계산한다. 



### 6) 실행결과 


![image](https://user-images.githubusercontent.com/63644587/116426741-5926e900-a87e-11eb-835e-9b2ed5342c2e.png)
![image](https://user-images.githubusercontent.com/63644587/116426751-5af0ac80-a87e-11eb-9850-311c59003023.png)
![image](https://user-images.githubusercontent.com/63644587/116426765-5d530680-a87e-11eb-827c-2e9e2556ce91.png)
- 이 외에 다양한 경우의 수(음수계수 등)을 테스트 한 결과 문제 없이 출력되었음


# II. 행렬의 곱셈과 덧셈

## 1. 방식 1(배열에 행렬 전체를 저장)을 활용한 행렬의 덧셈과 곱셈


### 1) 행렬의 입력 : main( )

- 과제의 요구사항에서 행렬은 정사각형으로 제한되므로 행렬의 규격을 shape 변수에 이를 입력받는다. 이 때 shape 변수는 전역변수로 설정하여 다양한 곳에서 활용될 수 있도록 했다.
- Shape 변수를 활용해 각 행렬이 들어갈 2차원 배열을 선언한다.
- 띄어쓰기 포함 (shape \* shape \* 2)개를 입력받으므로 input[shape \* shape \* 2] 문자열을 선언하여 행렬1과 2의 데이터를 입력받는다. 
- 입력 받은 데이터를 각 배열에 저장한다. 
- strtok을 활용하여 공백을 기준으로 분할하여 각 항의 값을 저장한다.
- 행과 열을 뜻하는 r과 c 변수를 선언하고 0으로 초기화한다.
- 해당 행과 열에 값을 저장한 후, c의 값을 증가시킨다.
- 만약 c값이 행렬의 규격에 도달 시 r값을 증가, c의 값을 0값으로 설정하여 행과 열에 접근할 수 있도록 한다.


### 2) 행렬의 출력 : void print\_matrix(int m[][shape])

- 2중 for 문을 활용하여 각 행렬의 정보를 출력한다.
- 한 행의 출력이 완료되면 ‘\n’을 출력하여 행을 전환한다.


### 3) 행렬의 덧셈 : void add\_normal(int A[][shape], int B[][shape])

- 결과 행렬인 2차원 배열 C를 새로이 선언한다.
- 행과 열을 뜻하는 변수 r과 c를 선언한다.
- 2중 for 문을 활용하여 A와 B의 동일한 행, 열에 해당하는 값을 더한 후 C에 대입한다.
- 이후 C배열을 출력하기 위해 print\_matrix 함수를 호출한다.


### 4) 행렬의 곱셈 : SparseMatrix multiply\_sparse(SparseMatrix a, SparseMatrix b)

- 결과 행렬인 2차원 배열 C를 새로이 선언한다.
- 3중 for 문을 활용하여 특정 위치의 곱셈 값을 구하기 위해 A의 행과 B의 열을 곱하는 연산을 수행한다. 이는 아래와 같다.
- ![](Aspose.Words.5d0761ac-de24-41a2-a695-086c205cbd2e.007.png)
- 해당 연산이 끝날 때 까지 곱셈값을 result에 지속적으로 임시저장한다.
- 이후 result값을 C에 추가하고, result를 초기화한 뒤 반복을 진행한다. 


### 5) 실행 결과

- 강의자료에 나온 수식 값을 기반으로 테스트 한 결과
- ![텍스트이(가) 표시된 사진

자동 생성된 설명](Aspose.Words.5d0761ac-de24-41a2-a695-086c205cbd2e.008.png)
- 이 외에 다양한 행렬을 테스트 한 결과 문제 없이 출력되었음

**2. 방식 2(희소행렬)을 활용한 행렬의 덧셈과 곱셈**

1) 행렬의 입력 : main( )

- 구조체 term, 행, 열, 항의 개수를 가지는 구조체 SparseMatrix를 총 4개 선언한다. 이 때 구조체 term은 하나의 구조체로서 행의 정보, 열의 정보, 행렬의 값을 묶어 관리한다.
- 과제의 요구사항에서 행렬은 정사각형으로 제한되므로 행렬의 규격을 shape 변수에 이를 입력받는다. 이 때 shape 변수는 전역변수로 설정하여 다양한 곳에서 활용될 수 있도록 했다.
- 띄어쓰기 포함 (shape \* shape \* 2)개를 입력받으므로 input[shape \* shape \* 2] 문자열을 선언하여 행렬1과 2의 데이터를 입력받는다. 
- 입력 받은 데이터를 각 구조체에 저장한다. 
- strtok을 활용하여 공백을 기준으로 분할하여 구조체의 data.value의 data\_idx번째 인덱스에 0이 아닌 항의 값을 저장한다.
- 행과 열을 뜻하는 r과 c 변수를 선언하고 0으로 초기화한다.
- strtok에 의해 문자열 분할 시 c의 값을 증가시킨다.
- 이후 c값이 행렬의 규격에 도달 시 r값을 증가, c의 값을 0값으로 설정하여 행과 열의 정보를 저장할 수 있도록 한다.
- 0이 아닌 항이 저장될 시 data\_idx와 구조체의 terms를 증가시킨다. 

2) 행렬의 덧셈 : SparseMatrix multiply\_add(SparseMatrix a, SparseMatrix b)

- 결과 다항식 구조체와 각 구조체의 항목을 가리키는 인덱스 변수 ca, ba, cc를 선언한다.
- 희소행렬의 저장되어있는 값이 일반행렬로 변환되었을 때 실제로 위치하는 순서를 a\_idx, b\_idx에 저장한다. 
- 각 행렬의 덧셈은 각 항의 실제 위치(a\_idx, b\_idx)를 비교함에 따라 진행된다.
- 첫째, 각 항의 위치가 다를 경우 더 앞선 항목의 값을 결과 행렬에 저장하고, 해당 희소행렬의 인덱스를 후순위로 바꾼다.
- 둘째, 각 항의 위치가 같을 경우 해당 항의 값을 모두 더한 값을 결과 행렬에 저장하고, 두 희소 행렬의 인덱스를 후순위로 바꾼다.
- 이러한 과정을 각 희소 행렬의 인덱스가 가장 마지막 항에 도달할 때 까지 반복한다.
- 각 희소 행렬에 남아있는 항들을 결과 행렬에 추가한다. 

3) 행렬의 곱셈 : SparseMatrix multiply\_sparse(SparseMatrix a, SparseMatrix b)

- 결과 다항식 구조체와 각 구조체의 항목을 가리키는 인덱스 변수 ca, ba, cc를 선언한다
- 희소행렬의 저장되어있는 값이 일반행렬로 변환되었을 때 실제로 위치하는 순서를 a\_idx, b\_idx에 선언하여 저장한다. 
- 각 행렬의 곱셈은 각 항의 실제 위치(a\_idx, b\_idx)를 고려하며 진행된다.
- A행렬의 희소행렬 항목이 곱해지는 B행렬의 범위는 전체 연산을 고려하였을 때 자신의 열에 해당하는 B행렬의 행이다.


<img width="644" alt="스크린샷 2021-04-29 오전 12 05 00" src="https://user-images.githubusercontent.com/63644587/116426957-8c697800-a87e-11eb-9897-8adeaa57e3da.png">



- 예를 들어 A[0,0]은 B[0, 0:2]와 곱해진 후 C[자신의 행, 곱해진 B항의 열]에 저장된다.
- 이는 다음의 연산과정으로 설명할 수 있다.
- C[0,0] = **A[0,0] \* B[0,0]** + A[0,1] \* B[1,0] + A[0,2] \* B[2,0]
- C[0,1] = **A[0,0] \* B[0,1]** + A[0,1] \* B[1,1] + A[0,2] \* B[2,1]
- C[0,2] = **A[0,0] \* B[0,2]** + A[0,1] \* B[1,2] + A[0,2] \* B[2,2]
- 이렇듯 A행렬의 특정 항은 곱하는 B행렬의 범위와 결과값이 저장되는 위치에 규칙을 보여준다.
- 그러므로 A희소행렬의 값이 연산되는 B의 범위를 정하여 결과행렬 C에 각기 저장한다.
- 즉, 기존의 행렬 곱셈 방식이 아니라, A행렬의 항별로 계산을 마친 후 전체를 합산하는 방식으로 이루어진다.
- 이를 위해 b\_start와 b\_end를 선언하고, 범위의 값을 계산한다. 
  - b\_start는 (특정 a항의 순차적 번호 / 규격)의 나머지를 규격과 곱한 값과 같다.
  - Ex) A[2, 1]의 a\_idx = 7이며, 이를 규격인 3으로 나누면 나머지 1, 즉 자신의 열값이 되고 이에 규격을 곱하면 3, 즉 B[1,0]이 시작위치가 된다.
  - b\_end는 시작위치에 규격 값 -1 을 더해 전체 행을 지정해준다.
  - Ex) A[2,1](7번째 항)이 곱해질 범위는 B[1,0:2](3~5번째 항)이 된다.
- 특정 A항의 범위에 속하는 B의 항들을 곱하여 각기 자리에 위치시키고 범위를 벗어나는 B값이 생기면 다음 A희소행렬의 항으로 넘어간다. 
- 이를 모든 A희소행렬에 대해 시행한다.
- 그러나 이러한 방법은 결과희소행렬값이 정렬되지 않는다는 단점이 있으므로, SparseMatrix sort\_matrix(SparseMatrix c)를 통해 정렬 후 반환한다.

4) 행렬의 출력 : void print\_matrix(SparseMatrix m)

- 구조체의 저장된 희소행렬의 행, 열, 값을 항의 개수만큼 반복하여 출력한다. 

5) 실행 결과

- 강의자료에 나온 수식 값을 기반으로 테스트 한 결과
<img width="353" alt="Aspose Words 5d0761ac-de24-41a2-a695-086c205cbd2e 008" src="https://user-images.githubusercontent.com/63644587/116427043-a1460b80-a87e-11eb-82ac-ecb18740b962.png">

![Aspose Words 5d0761ac-de24-41a2-a695-086c205cbd2e 009](https://user-images.githubusercontent.com/63644587/116427055-a440fc00-a87e-11eb-8545-337dcd8ced73.png)
- 이 외에 다양한 행렬을 테스트 한 결과 문제 없이 출력되었음




