**2021자료구조**

**과제4 – 사전만들기, 연결리스트 응용**






![](Aspose.Words.ad2d0542-c521-4f53-bbe8-e51ad5841d7f.001.jpeg)



**중앙대학교**

**자료구조 05분반**

**20176963 홍지중**

**목 차**


**1. 사전만들기……………………………………………………………...3**

**1) 연결리스트 구조…………………………………………………………………………….3**

**2) 사전 생성……………………………………………………………………………………..4**

**3) 탐색 및 추가…………………………………………………………………………………4**

**4) 출력 결과……………………………………………………………………………………..5**

**5) 개선 전후 비교……………………………………………………………………………...6**

**2. 연결리스트 응용…………………………….………………………..9**

**1) 연결리스트 구조……………………………………………………………………………9**

**2) 데이터 생성………………………………………………………………………………..10**

**3) 데이터 저장………………………………………………………………………………..11**

**3) 출력 결과…………………………………………………………………………………..12**

**

**1. 사전 만들기**

**1) 연결리스트 구조**

- 노드 class
- 하나의 데이터를 의미하는 노드는 다음과 같은 구조로 이루어져 있다.
- self.word : 영단어
- self.meaning : 영단어의 뜻
- self.next : 다음 노드의 주소

- 연결리스트(Dictionary class)
- 연결리스트는 단방향으로 구성된 연결리스트를 활용하며 맨 앞 노드를 가리키는 head와 맨 뒤 노드를 가리키는 tail를 운용함과 동시에 노드의 갯수를 의미하는 size 변수를 운용한다.
- 해당 클래스의 method에 대한 ADT는 다음과 같다.

def get\_node(self, pos): 

`    `return node

\# pos 번째에 해당하는 노드의 주소를 반환한다.

def insert(self, pos, word, meaning):

\# pos번째 노드에 word, meaning으로 이루어진 노드를 추가한다.

def insert\_new(self, pos, idx, word, meaning): 

\# idx번째에 해당하는 리스트(idx번째 알파벳)의 pos번째 노드에 word, meaning

`  `으로 이루어진 노드를 추가한다.

def where\_to\_insert(self, word):

`    `return pos

\# 해당 단어가 추가될 위치를 찾는다.

def concat(self, list): 

\# 두개의 연결리스트를 하나의 연결리스트로 병합한다.

def search(self, target):

`    `return meaning

\# 리스트 내에서 target에 해당하는 단어의 뜻을 찾는다. 

def display(self):

\# 리스트의 영단어를 출력한다.

**2) 사전 생성**

- 분할된 리스트 생성
- 사전 초기화 및 탐색의 효율성을 증대하기 위하여 개별 알파벳 별 연결리스트를 선언한다.
- a~z 까지 총 26개의 Dictionary 클래스를 선언하고, 이에 대한 참조변수들을 index라는 리스트에 넣어 운용한다.

|index[]|
| :- |
|a 사전|b 사전|c 사전|d 사전|e 사전|…|z 사전|
|0|1|2|3|4|…|25|

- 추가할 단어의 리스트 할당
- txt 파일에서 한줄씩 읽어 split을 통해 단어와 뜻을 분리한다. 만약 뜻이 빈 경우 추가하지 않는다.
- 추출된 단어의 첫 글자의 아스키코드에서 a를 의미하는 97을 빼어 분할된 리스트에 접근할 수 있는 변수 idx를 계산한다.
- 각 알파벳별 리스트의 참조변수인 index List의 해당 알파벳 리스트에 접근한다.
- 예를 들어 apple을 추가한다면 index[0]에 접근하게 된다.

- 단어 추가
- where\_to\_insert(self, word) 메소드를 호출하여 해당 리스트에서 추가할 단어가 삽입될 위치를 찾는다. 이는 맨 앞 head에서부터 순차적으로 순회하며 더 큰 단어를 만났을 때 해당 위치를 반환한다.
- 해당 위치에 insert(self, pos, word, meaning)을 호출하여 지정 위치에 단어와 뜻을 삽입한다.

- 분할된 리스트 병합
- 모든 단어가 알파벳별로 분리되어 저장되었다면 이를 하나로 이어주는 작업을 수행한다.
- concat(self, list) 메소드를 통해 두 리스트를 연결한다. 이는 앞 리스트의 마지막 노드가 뒤 리스트의 첫번째를 가리키도록 함으로써 이루어진다.
- 모든 리스트가 하나로 연결되었다면 eng\_dict 인스턴스를 생성하여 이것의 head를 index[0]의 head로, tail을 index[25]의 tail로 지정하고, 통합된 size로 초기화한다.

**3) 탐색 및 추가**

- 탐색 
- 입력받은 단어를 target에 저장한다.
- 사전 초기화와 동일하게 탐색의 효율성을 위하여 해당 단어의 알파벳부터 탐색을 시작한다.
- 이를 위해 동일하게 ascii코드를 연산하여 idx를 계산하고, 해당 참조변수를 통해 해당 알파벳 리스트의 가장 첫 노드에 접근한다.
- search(self, target) 메소드를 통해 리스트의 노드를 순회하며 해당 단어를 찾는다.
- 만약 찾는 단어가 있다면 그 단어의 뜻을 반환하고 없다면 None을 반환한다.
- 반환 받은 단어의 뜻을 출력한다.

- 추가 
- 만약 해당하는 단어가 없다면 뜻을 추가하여 리스트에 저장한다. 
- 이를 위해 이미 ascii코드로 계산된 idx를 기반으로 where\_to\_insert(self, word) 메소드를 호출하여 해당 리스트에서 추가할 단어가 삽입될 위치를 찾는다.
- 해당 위치에 insert\_new(self, pos, idx, word, meaning)을 호출하여 지정 위치에 단어와 뜻을 삽입한다.
- 사전 초기화의 Insert와 다른 메소드를 운용하는 이유는, 새로운 메소드없이 운용은 가능하나, 현재 모든 리스트가 병합되었으므로 전체리스트에서 해당 알파벳의 위치로 바로 접근하여 추가하고, 전체 리스트의 size 최신화하기 위함이다.

**4) 출력 결과**

- 추가된 단어의 정렬 
- 오름차순으로 정렬이 된 것을 확인할 수 있다.

![](Aspose.Words.ad2d0542-c521-4f53-bbe8-e51ad5841d7f.002.png)

![](Aspose.Words.ad2d0542-c521-4f53-bbe8-e51ad5841d7f.002.png)

- 단어 검색
- 정상적으로 존재하는 단어에 대한 뜻을 출력한다.

![텍스트이(가) 표시된 사진

자동 생성된 설명](Aspose.Words.ad2d0542-c521-4f53-bbe8-e51ad5841d7f.003.png)

- 단어 추가
- 존재하지 않는 단어를 뜻을 입력받아 추가한다.

![텍스트이(가) 표시된 사진

자동 생성된 설명](Aspose.Words.ad2d0542-c521-4f53-bbe8-e51ad5841d7f.004.png)

- 새로 추가하는 경우에도 오름차순으로 정렬이 된 것을 확인할 수 있다.

![](Aspose.Words.ad2d0542-c521-4f53-bbe8-e51ad5841d7f.005.png)

**5) 개선 전후 비교**

- 연결리스트의 경우 random access가 불가능하여 이진탐색을 수행할 수 없다. 이에 오로지 선형으로 탐색완료시까지 전체 노드를 순회하여야 하는 단점이 있다. 이는 데이터 양이 많아질수록 소요시간 역시 크게 증가함을 의미한다.

- 이에 실제 우리가 사전에서 단어를 찾을 때 해당 알파벳부터 찾는 것처럼, 알파벳을 기준으로 리스트의 색인을 유지하고, 특정 단어를 삽입 혹은 검색 시 활용하여 바로 접근할 수 있도록 하였다. 

- 이를 테스트하기 위해서 각 노드를 순회하는 횟수를 비교하였다.
- where\_to\_insert 메소드와 search 메소드에 count 변수를 운용하여 다음 노드로 이동할 때 마다 이를 1씩 추가해주었다. 
- 이후 해당 메소드의 원래 반환값과 함께 count를 tuple 형태로 반환한다.
- main 메소드에서는 이러한 결과값을 저장하는 세가지 변수 혹은 자료형을 운용한다.
  - init\_count : 사전 초기화 시 총 순회 횟수를 저장한다.
  - operation\_per\_word[]: 단어 하나가 저장될 때까지의 순회 횟수를 저장한다.
  - search\_count{} : 딕셔너리에 특정 단어를 검색했을 때 순회 횟수를 저장한다.
  - 해당 값을 각 방식이 종료될 때 반환한다.

- validate\_improvement( )
- 각 방식별로 연산횟수를 반환받아 이를 기반으로 개선이 타당한지 확인한다.
- 횟수와 함께 그래프, 통계를 통해 타당성을 검증하였다. 

- 연산횟수
- txt 파일로부터 사전을 만드는 작업에 소요되는 노드 순회 횟수와 특정 단어를 찾았을 때 소요되는 노드 순회 횟수는 다음과 같다.

![텍스트이(가) 표시된 사진

자동 생성된 설명](Aspose.Words.ad2d0542-c521-4f53-bbe8-e51ad5841d7f.006.png)

- 사전 초기화 작업의 경우 전체를 순회할 때 횟수가 약 6억회에 달하는 반면 개선된 경우에는 3천 5백만회로 약 17배 적은 것을 알 수 있다. 
- 단어 검색의 경우 첫 알파벳, 중간 알파벳, 마지막 알파벳으로 테스트 하였다.
  - a의 경우 둘 다 맨 앞에서 순회하므로 동일하다.
  - 기존 알고리즘에서 m의 경우 알파벳 중간에 해당하므로 전체 데이터의 약 절반만큼, z의 경우 알파벳 마지막에 해당하므로 전체데이터 만큼 순회한다.
  - 그러나 개선된 알고리즘에서는 알파벳의 순서와 관계 없이 해당 알파벳의 첫 노드부터 순회하므로 현저히 개선된 것을 볼 수 있다.
- 그래프 
- 개별 단어를 추가하는데 소요되는 연산의 횟수를 그래프로 나타내면 다음과 같다.
- 막대그래프

![](Aspose.Words.ad2d0542-c521-4f53-bbe8-e51ad5841d7f.007.png)

- 선그래프

![](Aspose.Words.ad2d0542-c521-4f53-bbe8-e51ad5841d7f.008.png)

- x축은 n번째 단어를 의미하며 y축은 해당 단어의 연산 횟수를 의미한다.
- 두 방식 모두 추가되는 데이터의 양이 많아질수록 연산의 횟수가 늘어남을 알 수 있다. 
- 그러나 개선된 알고리즘의 경우 단어들이 알파벳별로 균일하게 분포하고 있다면 연산의 횟수가 크게 절감됨을 알 수 있다. 다만 모든 데이터가 특정 알파벳에 몰려있다면 이것의 효과는 크지 않으며 최악의 경우 개선전후가 동일하게 된다.

- 히스토그램

![](Aspose.Words.ad2d0542-c521-4f53-bbe8-e51ad5841d7f.009.png) 

- x축은 연산의 횟수를 의미하며, y축은 그러한 횟수의 빈도를 의미한다.
- 두 방식의 분포를 살펴보면 위와 같이 연산의 횟수가 커질수록 빈도가 줄어들고 있음을 보여준다. 이는 기존의 데이터의 정렬 정도에 기반하여 대부분의 경우 마지막 노드까지 순회하기보다 중간에 자신의 위치를 찾는 경우가 많음을 의미한다.
- 기존 알고리즘의 경우 연산 횟수가 데이터의 갯수까지 분포하고 있음을 확인할 수 있다.
- 그러나 개선 알고리즘의 경우 동일한 데이터를 처리했지만 약 5천번까지 분포하고 있으며, 적은 연산횟수의 빈도가 잦은 한편, 기존 알고리즘에 비해 큰 연산횟수의 빈도가 급격히 줄어드는 것을 확인할 수 있다. 

- 통계
- 개별 단어를 추가하는데 소요되는 연산의 횟수를 통계적인 수치로 나타내면 다음과 같다. 최솟값은 0으로 동일하다.


||**최댓값**|**평균값**|**중위값**|**표준편차**|
| - | - | - | - | - |
|**개선 전**|48043|12112|9021|10686|
|**개선 후**|5490|736|462|808|

- 최대 연산 횟수는 개선 전의 경우 전체 데이터에 근사하게 나타나는 반면, 개선 후에는 하나의 데이터를 추가할 때 드는 연산의 횟수의 최댓값이 전체 데이터의 11%에 불과함을 확인할 수 있다.
- 개선 전의 평균값과 중위값 모두 개선 후보다 상당히 크므로 개선 전의 최댓값에 의한 평균의 왜곡으로 알고리즘의 효율성 평가가 왜곡되지 않음을 확인할 수 있다.
- 표준편차를 살펴보았을 때 연산 횟수의 분포가 개선 전의 경우 매우 넓고 불안정하게 되어있는 반면, 개선 후 연산 횟수의 분포가 상대적으로 안정적이다.

**2. 연결리스트 응용** 

**1) 연결리스트 구조**

- 노드 class
- 하나의 데이터를 의미하는 노드는 다음과 같은 구조로 이루어져 있다.
- self.id : 학번
- self.name : 이름
- self.phone : 전화번호
- self.next\_id : 다음 학번 노드의 주소
- self.next\_name : 다음 이름 노드의 주소

- 연결리스트(Student class)
- 연결리스트는 단방향으로 구성된 연결리스트를 활용하며, 두 개의 연결리스트를 구현하지 않고 하나의 연결리스트에서 두 갈래의 화살표를 활용한다. 하나의 연결리스트에서 정렬된 두 정보를 찾아갈 수 있도록 head\_id와 head\_name을 운용함과 동시에 노드의 갯수를 의미하는 size 변수를 운용한다.
- 해당 클래스의 method에 대한 ADT는 다음과 같다.

def get\_node\_id(self, pos): 

`    `return node

\# pos 번째에 해당하는 노드의 주소를 반환한다.

def get\_node\_name(self, pos): 

`    `return node

\# pos 번째에 해당하는 노드의 주소를 반환한다.

def insert\_id (self, pos, student\_id, name, phone):

\# pos번째 노드에 학번, 이름, 전화번호로 이루어진 노드를 추가한다.

def insert\_name(self, pos, Node):

\# pos번째 노드에 이미 구성된 노드를 연결한다.


def where\_to\_insert\_id(self, id):

`    `return pos

\# 해당 학번이 정렬될 위치를 찾는다.

def where\_to\_insert\_name(self, name):

`    `return pos

\# 해당 이름이 정렬될 위치를 찾는다.





def display\_id(self):

\# 학번순으로 리스트를 출력한다.

def display\_name(self):

\# 이름순으로 리스트를 출력한다.


**2) 데이터 생성**

- 데이터의 생성
- 중복이 없는 학번을 생성한 후 이에 대한 무작위 이름과 전화번호를 할당하는 방식으로 이루어진다. 이 때 이름과 전화번호는 중복이 가능하다.

- 학번 : student\_id\_list = random.sample(range(20130000, 20200000), 10000)
- random 모듈의 sample 메소드를 활용하여 10000개의 학번을 생성한다.
- 이는 주어진 범위 내에서 비복원 추출을 하는 것으로 20130000 ~ 20219999 사이에서 무작위로 size 만큼 추출하여 student\_id\_list에 저장한다.

- 이름 : name = "". join([random.choice(string.ascii\_lowercase) for \_ in range(len\_name)])
- random 모듈의 choice 메소드를 활용한다. 
- 이는 주어진 범위 내에서 1개를 선택하는 것으로 string 클래스의 ascii\_lowercase에서 소문자 한 개를 선택하도록 한다. 
- 10자 이내의 이름을 생성해야 하므로 1~10 중 무작위 수를 생성하여 len\_name에 저장한다.
- 이와 같은 과정을 list comprehension을 통해 len\_name 만큼 반복하고 하나의 리스트에 넣는다. 
- 이후 join 메소드를 통해 리스트 내부의 element를 문자열로 합쳐 반환토록 한다.

- 전화번호 : phone\_number = "010" + "".join([str(random.randint(0, 9)) for \_ in range(8)])
- random 모듈의 randint 메소드를 활용한다. 
- 이는 주어진 정수범위 내에서 1개를 추출하는 것으로 0~9범위에서 진행한다. 
- 이름과 동일하게 전화번호 뒷부분에 해당하는 8자리 숫자를 생성한다. 
- 다만 join 메소드의 인자의 형은 문자형태이므로 타입 캐스팅을 통해 정수형을 문자열로 변경한다. 
- 이렇게 생성된 8자리 숫자와 010을 합친다. 




**3) 데이터 저장**

- 학번 기준 정렬
- where\_to\_insert\_id 메소드를 활용하여 학번 기준으로 삽입할 곳을 탐색한다.
  - 시작위치를 head\_id로 하여 가장 빠른 학번부터 탐색하여 추가할 노드보다 더 큰 노드를 만나면 그 위치를 반환한다.
  - 만약 마지막 노드까지 탐색하였다면 맨 마지막에 추가해야므로 마지막 노드 위치를 반환한다.
- Insert\_id 메소드를 활용하여 학번 기준으로 노드를 삽입한다.
  - get\_node\_id 메소드로 추가할 곳의 이전 노드 위치를 확인한다.
  - 인자로 받은 학번, 이름, 전화번호로 새로운 노드를 생성한다.
  - 만약 이전 노드가 없다면 맨 앞에 추가해야하므로 새로 추가한 노드가 현재 맨 앞 노드의 위치를 가리키도록 하는 한편, head\_id가 새로 추가한 노드를 가리키도록 한다.
  - 이 외에는 새로 추가한 노드가 다음 노드의 위치를 가리키도록 하고, 이전 노드의 위치를 새로 추가한 노드가 가리키도록 한다. 
  - 이후 새로 추가한 노드의 주소를 반환한다.

- 이름 기준 정렬
- where\_to\_insert\_name 메소드를 활용하여 이름 기준으로 삽입할 곳을 탐색한다.
  - 시작위치를 head\_name으로 하여 가장 빠른 이름부터 탐색하여 추가할 노드보다 더 큰 노드를 만나면 그 위치를 반환한다.
  - 만약 마지막 노드까지 탐색하였다면 맨 마지막에 추가해야므로 마지막 노드 위치를 반환한다.
- Insert\_name 메소드를 활용하여 학번 기준으로 노드를 연결한다.
  - get\_node\_name 메소드로 추가할 곳의 이전 노드 위치를 확인한다.
  - 인자로 이미 생성된 노드를 받아 이를 활용한다.
  - 만약 이전 노드가 없다면 맨 앞에 연결해야하므로 새로 추가하는 노드가 현재 맨 앞 노드의 위치를 가리키도록 하는 한편, head\_name이 새로 추가한 노드를 가리키도록 한다.
  - 이 외에는 새로 추가한 노드가 다음 노드의 위치를 가리키도록 하고, 이전 노드의 위치를 새로 추가한 노드가 가리키도록 한다. 

- 위 과정을 거쳐 하나의 연결리스트에서 정렬된 두 가지 경로를 유지할 수 있게 된다.

![](Aspose.Words.ad2d0542-c521-4f53-bbe8-e51ad5841d7f.010.jpeg)

**4) 출력**

- 입력받은 숫자에 따라 모드를 설정하고 display\_id( ) 혹은 display\_name( )을 호출한다. 
- 각 메소드는 head\_id 혹은 head\_name에서부터 마지막 노드까지 순회하며 정보를 출력한다.
- 이 떄 100명씩 건너뛰며 출력해야하므로 모듈러 연산을 통해 출력할 인덱스를 결정한다.
- 학번순 출력 결과 정상적으로 출력되었다.

![텍스트, 명판이(가) 표시된 사진

자동 생성된 설명](Aspose.Words.ad2d0542-c521-4f53-bbe8-e51ad5841d7f.011.png) ![텍스트, 명판이(가) 표시된 사진

자동 생성된 설명](Aspose.Words.ad2d0542-c521-4f53-bbe8-e51ad5841d7f.012.png)




- 이름순 출력 결과 정상적으로 출력되었다.

![텍스트, 명판이(가) 표시된 사진

자동 생성된 설명](Aspose.Words.ad2d0542-c521-4f53-bbe8-e51ad5841d7f.013.png) ![텍스트이(가) 표시된 사진

자동 생성된 설명](Aspose.Words.ad2d0542-c521-4f53-bbe8-e51ad5841d7f.014.png)
` `PAGE 2

