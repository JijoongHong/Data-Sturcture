**목 차**

**1. 수식 트리**

> **1) 트리 구조**
>
> **2) 트리 생성**
>
> **3) 수식 계산**
>
> **4) 트리 순회**
>
> **5) 출력 결과**



# **1. 수식 트리 만들기**

## **1) 트리 구조**

-   Node class

<!-- -->

-   하나의 데이터를 의미하는 노드는 다음과 같은 구조로 이루어져 있다.

-   self.item : 연산자 혹은 피연산자

-   self.left : 왼쪽 노드의 주소

-   self.right : 오른쪽 노드의 주소

<!-- -->

-   이진트리(Tree class)

<!-- -->

-   이진트리는 가장 상위 레벨의 노드를 가리키는 root 변수를 운용한다.

-   해당 클래스의 method에 대한 ADT는 다음과 같다.

> def init\_tree(self, exp):\
> \# 수식을 인자로 받아 트리를 구성
>
> def preorder(self, root):\
> \# 인자로 받은 루트노드부터 전위 순회
>
> def inorder(self, root):
>
> \# 인자로 받은 루트노드부터 중위 순회
>
> def postorder(self, root):\
> \# 인자로 받은 루트노드부터 후위 순회
>
> def level(self, root):\
> \# 인자로 받은 루트노드로부터 레벨 순회
>
> def evaluate(self, root):
>
> \# 구성된 수식 트리 계산

## **2) 트리 생성**

-   후위 수식 변경

<!-- -->

-   postfix(exp)를 통해 입력받은 중위 수식을 후위 수식으로 변경한다.

-   이를 위해 stack 리스트와 result 리스트를 운용한다.

-   수식을 한 글자씩 순회하며 연산자와 피연산자를 구분한다.

-   만약 피연산자라면 그대로 result리스트에 추가한다.

-   만약 연산자라면 해당 연산자의 우선순위에 따라 작업의
    형태가 달라진다.

    -   우선순위를 정하기 위하여 get\_priority 메소드를 호출한다. 만약
        \*나 /라면 0을, +나 -라면 1을, 피연산자라면 2를 반환한다.

    -   만약 스택에 데이터가 존재하고, 현재 연산자가 스택의 데이터보다
        우선순위가 같거나 낮다면 우선순위가 높은 데이터를 모두 result에
        추가하고 현재 연산자를 스택에 추가한다.

    -   만약 스택에 데이터가 없거나 스택의 데이터보다 우선순위가 높다면
        그대로 스택에 추가한다.

-   만약 스택에 남은 데이터가 있다면 result에 모두 추가한다.

-   result를 반환하고, main( )에서 이를 join메소드를 통해
    문자열로 변환한다.

<!-- -->

-   트리 구성

<!-- -->

-   init\_tree(self, exp)메소드를 통해 입력받은 후위 수식으로
    트리를 구성한다.

-   이를 위해 stack 리스트를 운용한다.

-   수식을 한 글자씩 순회하며 연산자와 피연산자를 구분한다.

-   만약 피연산자라면 피연산자를 정수형으로 캐스팅한 후 이를 item으로
    삼는 노드를 생성한다. 이후 stack에 삽입한다.

-   만약 연산자라면 해당 연산자를 item으로 하는 노드를 생성한다. 해당
    노드의 오른쪽 노드와 왼쪽 노드를 stack에서 pop하여 지정한다. 이후
    해당 노드를 stack에 push한다.

    -   이 경우 구성된 노드 3개의 이진트리 root가 stack에 push된다.
        그러므로 우선순위가 낮은 연산자의 자식 노드로 root가 올 수 있어
        자연스레 서브트리가 구성된다.

## **3) 수식 계산**

-   evaluate(self, root)메소드를 통해 입력받은 루트부터 재귀적으로
    수식을 계산한다.

<!-- -->

-   만약 입력받은 루트가 None이라면 더 이상 계산할 것이 없으므로
    0을 반환한다.

-   만약 입력받은 루트의 자식노드가 없다면 피연산자인 리프노드에
    해당하므로 현재 노드의 item을 반환한다.

-   만약 이 경우에 해당하지 않는다면, 즉 연산자라면 재귀적으로 각 자식
    노드에 대한 evaluate를 진행한 후 각 반환된 값에 연산을 진행한다.

## **4) 순회**

-   전위순회

<!-- -->

-   전위순회는 V-L-R 순으로 트리를 순회한다.

-   인자로 받은 노드가 None이 아니라면 우선 root에 해당하는 현재 노드의
    값을 출력한다.

-   이후 좌측에 대해 재귀적으로 전위순회 메소드를 호출한 후, 우측에 대해
    재귀적으로 전위순회 메소드를 호출한다.

<!-- -->

-   중위순회

<!-- -->

-   중위순회는 L-V-R 순으로 트리를 순회한다.

-   인자로 받은 노드가 None이 아니라면 우선 좌측에 대해 재귀적으로
    전위순회 메소드를 호출한다.

-   이후 root에 해당하는 현재 노드의 값을 출력한 후, 우측에 대해
    재귀적으로 전위순회 메소드를 호출한다.

<!-- -->

-   후위순회

<!-- -->

-   후위순회는 L-R-V 순으로 트리를 순회한다.

-   인자로 받은 노드가 None이 아니라면 우선 좌측에 대해 재귀적으로
    전위순회 메소드를 호출한다.

-   이후 우측에 대해 재귀적으로 전위순회 메소드를 호출한 후, root에
    해당하는 현재 노드의 값을 출력한다.

<!-- -->

-   레벨순회

<!-- -->

-   레벨 순회는 각 레벨별로 좌측에서 우측으로 트리를 순회한다.

-   이를 위해 큐를 운용한다.

-   현재 노드를 출력하고, 좌측과 우측의 노드를 큐에 입력한다.

-   이후 큐에서 하나씩 dequeue하여 동일한 작업을 큐가 빌 때
    까지 반복한다.

## **5) 출력 결과**

   ![image](https://user-images.githubusercontent.com/63644587/119696591-4eb23c00-be8a-11eb-8717-b39484f1b9a8.png)
   
   ![image](https://user-images.githubusercontent.com/63644587/119696613-57a30d80-be8a-11eb-8f1a-1778fab951e9.png)

