**목 차**

**1. 수식 트리**

> **1) 트리 구조**
>
> **2) 트리 생성**
>
> **3) 수식 계산**
>
> **4) 트리 순회**
>
> **5) 출력 결과**



**1. 수식 트리 만들기**

**1) 트리 구조**

-   Node class

<!-- -->

-   하나의 데이터를 의미하는 노드는 다음과 같은 구조로 이루어져 있다.

-   self.item : 연산자 혹은 피연산자

-   self.left : 왼쪽 노드의 주소

-   self.right : 오른쪽 노드의 주소

<!-- -->

-   이진트리(Tree class)

<!-- -->

-   이진트리는 가장 상위 레벨의 노드를 가리키는 root 변수를 운용한다.

-   해당 클래스의 method에 대한 ADT는 다음과 같다.

> def init\_tree(self, exp):\
> \# 수식을 인자로 받아 트리를 구성
>
> def preorder(self, root):\
> \# 인자로 받은 루트노드부터 전위 순회
>
> def inorder(self, root):
>
> \# 인자로 받은 루트노드부터 중위 순회
>
> def postorder(self, root):\
> \# 인자로 받은 루트노드부터 후위 순회
>
> def level(self, root):\
> \# 인자로 받은 루트노드로부터 레벨 순회
>
> def evaluate(self, root):
>
> \# 구성된 수식 트리 계산

**2) 트리 생성**

-   후위 수식 변경

<!-- -->

-   postfix(exp)를 통해 입력받은 중위 수식을 후위 수식으로 변경한다.

-   이를 위해 stack 리스트와 result 리스트를 운용한다.

-   수식을 한 글자씩 순회하며 연산자와 피연산자를 구분한다.

-   만약 피연산자라면 그대로 result리스트에 추가한다.

-   만약 연산자라면 해당 연산자의 우선순위에 따라 작업의
    형태가 달라진다.

    -   우선순위를 정하기 위하여 get\_priority 메소드를 호출한다. 만약
        \*나 /라면 0을, +나 -라면 1을, 피연산자라면 2를 반환한다.

    -   만약 스택에 데이터가 존재하고, 현재 연산자가 스택의 데이터보다
        우선순위가 같거나 낮다면 우선순위가 높은 데이터를 모두 result에
        추가하고 현재 연산자를 스택에 추가한다.

    -   만약 스택에 데이터가 없거나 스택의 데이터보다 우선순위가 높다면
        그대로 스택에 추가한다.

-   만약 스택에 남은 데이터가 있다면 result에 모두 추가한다.

-   result를 반환하고, main( )에서 이를 join메소드를 통해
    문자열로 변환한다.

<!-- -->

-   트리 구성

<!-- -->

-   init\_tree(self, exp)메소드를 통해 입력받은 후위 수식으로
    트리를 구성한다.

-   이를 위해 stack 리스트를 운용한다.

-   수식을 한 글자씩 순회하며 연산자와 피연산자를 구분한다.

-   만약 피연산자라면 피연산자를 정수형으로 캐스팅한 후 이를 item으로
    삼는 노드를 생성한다. 이후 stack에 삽입한다.

-   만약 연산자라면 해당 연산자를 item으로 하는 노드를 생성한다. 해당
    노드의 오른쪽 노드와 왼쪽 노드를 stack에서 pop하여 지정한다. 이후
    해당 노드를 stack에 push한다.

    -   이 경우 구성된 노드 3개의 이진트리 root가 stack에 push된다.
        그러므로 우선순위가 낮은 연산자의 자식 노드로 root가 올 수 있어
        자연스레 서브트리가 구성된다.

**3) 수식 계산**

-   evaluate(self, root)메소드를 통해 입력받은 루트부터 재귀적으로
    수식을 계산한다.

<!-- -->

-   만약 입력받은 루트가 None이라면 더 이상 계산할 것이 없으므로
    0을 반환한다.

-   만약 입력받은 루트의 자식노드가 없다면 피연산자인 리프노드에
    해당하므로 현재 노드의 item을 반환한다.

-   만약 이 경우에 해당하지 않는다면, 즉 연산자라면 재귀적으로 각 자식
    노드에 대한 evaluate를 진행한 후 각 반환된 값에 연산을 진행한다.

**4) 순회 **

-   전위순회

<!-- -->

-   전위순회는 V-L-R 순으로 트리를 순회한다.

-   인자로 받은 노드가 None이 아니라면 우선 root에 해당하는 현재 노드의
    값을 출력한다.

-   이후 좌측에 대해 재귀적으로 전위순회 메소드를 호출한 후, 우측에 대해
    재귀적으로 전위순회 메소드를 호출한다.

<!-- -->

-   중위순회

<!-- -->

-   중위순회는 L-V-R 순으로 트리를 순회한다.

-   인자로 받은 노드가 None이 아니라면 우선 좌측에 대해 재귀적으로
    전위순회 메소드를 호출한다.

-   이후 root에 해당하는 현재 노드의 값을 출력한 후, 우측에 대해
    재귀적으로 전위순회 메소드를 호출한다.

<!-- -->

-   후위순회

<!-- -->

-   후위순회는 L-R-V 순으로 트리를 순회한다.

-   인자로 받은 노드가 None이 아니라면 우선 좌측에 대해 재귀적으로
    전위순회 메소드를 호출한다.

-   이후 우측에 대해 재귀적으로 전위순회 메소드를 호출한 후, root에
    해당하는 현재 노드의 값을 출력한다.

<!-- -->

-   레벨순회

<!-- -->

-   레벨 순회는 각 레벨별로 좌측에서 우측으로 트리를 순회한다.

-   이를 위해 큐를 운용한다.

-   현재 노드를 출력하고, 좌측과 우측의 노드를 큐에 입력한다.

-   이후 큐에서 하나씩 dequeue하여 동일한 작업을 큐가 빌 때
    까지 반복한다.

**5) 출력 결과**

> ![](media/image2.png){width="2.520246062992126in"
> height="1.8018864829396326in"}
> ![](media/image3.png){width="3.2894652230971126in"
> height="1.8017300962379703in"}

**2. 사전 탐색트리 만들기**

**1) 트리 구조**

-   노드 class

<!-- -->

-   하나의 데이터를 의미하는 노드는 다음과 같은 구조로 이루어져 있다.

-   self.word : 영단어

-   self.meaning : 영단어의 뜻

-   self.left : 왼쪽 노드의 주소

-   self.right : 오른쪽 노드의 주소

<!-- -->

-   이진탐색트리(BinarySearchTree class)

<!-- -->

-   이진트리는 가장 상위 레벨의 노드를 가리키는 root 변수를 운용한다.

-   해당 클래스의 method에 대한 ADT는 다음과 같다.

> def search(self, word, level):\
> \# 찾고자 하는 단어와 레벨변수(초기값0) 인자로 받아 트리가 구성되지
> 않았으면
>
> 0을, 구성되었다면 \_\_search\_node를 호출하여 그 값을 반환한다.\
> \
> def \_\_search\_node(self, cur, word, level):
>
> \# 현재 노드와 찾고자 하는 단어, 레벨변수(초기값0)을 인자로 받아 해당
> 단어가
>
> 존재한다면 뜻을 찾아 반환한다.
>
> def insert(self, word, meaning):
>
> \# 삽입하고자 하는 단어와 뜻을 입력받아 트리가 구성되지 않았으면
> root에
>
> 삽입하고, 그렇지 않으면 \_\_insert\_node를 호출하여 그 값을 삽입한다.
>
> def \_\_insert\_node(self, cur, word, meaning):
>
> \# 현재 노드와 단어, 뜻을 입력받아 적절한 위치에 노드를 삽입한다.\
> \
> def count\_node(self, node):\
> \# 트리에 구성된 노드의 갯수를 반환한다.\
> \
> def cal\_height(self, node):
>
> \# 트리의 높이를 반환한다.

**2) A트리 생성**

-   데이터 파싱(main)

<!-- -->

-   txt 파일에서 한줄씩 읽어 split을 통해 단어와 뜻을 분리한다.

<!-- -->

-   트리 생성(self.insert)

<!-- -->

-   BinarySearchTree인스턴스를 생성하고, 단어와 뜻을 인자로 하여 insert
    메소드를 호출한다.

-   첫번째 단어의 경우 root노드에 삽입된다.

-   이후의 경우 기존 인자에 root노드를 더해 \_\_insert\_node
    메소드를 호출한다.

    -   이진탐색트리의 경우 루트노드를 기준으로 좌측에는 루트노드보다
        작은 항목이, 우측에는 루트노드보다 큰 항목이 자리한다.

    -   이에 현재 기준노드와 단어를 비교한 후, 루트노드보다 작다면
        좌측으로, 크다면 우측으로 자리하게 된다.

    -   이 때 기준노드의 왼쪽 혹은 오른쪽이 비어있다면 단어와 뜻으로
        노드를 생성하고 해당 자리에 노드를 삽입한다.

    -   만약 기준노드의 왼쪽이 비어있지 않다면 기준노드의 왼쪽을 다시
        기준노드로, 기준 노드의 오른쪽이 비어있지 않다면 기준노드의
        오른쪽을 다시 기준노드로 하여 재귀적으로 호출한다.

    -   위 일련의 과정은 탐색의 과정과 유사하다. 해당 노드가 위치해야할
        곳을 지속적으로 찾아나가 빈 자리에 해당 노드를 삽입하는 것이다.

**3) A트리 탐색**

-   랜덤 데이터 생성

<!-- -->

-   txt파일에 대해 readlines( )로 전체 데이터를 리스트 형태로 불러온다.

-   0 \~ 사전 갯수-1 까지의 정수를 랜덤하게 뽑은 후, 해당 인덱스의
    데이터를 가져온다.

-   이를 split을 통해 좌측만 추출한 후 리스트에 추가한다.

    -   위의 일련의 과정을 list comprehension을 통해 다음과
        같이 표현하였다.

    -   random\_words = \[lines\[random.randint(0, count-1)\].split(" :
        ")\[0\] for \_ in range(10)\]

<!-- -->

-   탐색

<!-- -->

-   랜덤 생성된 단어를 하나씩 탐색하고 그 결과를 출력한다.

-   이를 위해 단어와 0(초기 level을 뜻하는 변수)를 인자로 하여
    search메소드를 호출한다.

    -   만약 루트노드가 비어있다면 None과 0을 튜플 형태로 반환한다.

    -   그렇지 않다면 루트노드를 현재 노드로 하여
        \_\_search\_node를 호출한다.

-   \_\_search\_node는 삽입연산과 마찬가지로 재귀적으로 호출된다. 이 때
    현재 노드를 의미하는 cur 변수와 레벨을 의미하는 level 변수를
    운용하게 된다.

-   만약 cur가 None이라면 말단의 리프노드까지 내려왔다는 것을 의미하므로
    더이상 찾을 것이 없어 None과 0을 튜플 형태로 반환한다.

-   만약 cur의 단어와 찾고자 하는 단어가 동일하다면 단어의 뜻과
    레벨을 반환한다.

-   만약 동일하지 않는다면 단어를 찾고자 자식 노드를 지속적으로
    탐색해야 한다.

    -   이진탐색트리는 루트노드를 기준으로 좌측에는 루트보다 작은 값이,
        우측에는 루트보다 큰 값이 존재한다.

    -   그러므로 루트노드와의 연산을 통해 좌측 또는 우측
        자식노드로 이동한다. 이 때 level변수를 1증가시켜 찾고자하는 값의
        레벨을 계산한다.

    -   이에 루트노드가 찾고자 하는 값보다 크다면 좌측 자식노드를 cur
        기준노드로 하여, 작다면 우측 자식노드를 cur 기준노드로 하여
        재귀적으로 호출한다.

**4) A트리 출력 결과**

> ![](media/image4.png){width="6.692250656167979in"
> height="2.038837489063867in"}

-   사전 파일을 읽기 전, 후의 시간을 측정하여 소요시간을 측정하였다.

-   생성된 노드의 갯수가 txt파일 내의 단어 갯수와 동일하다.

<!-- -->

-   이를 위해 root를 인자로 받는 self.count\_node 메소드를 운용한다.

-   만약 root가 비어있다면 더 이상 내려갈 곳이 없음을 의미하므로
    0을 반환한다.

-   그렇지 않다면 재귀적으로 노드의 개수를 구한다.

    -   이는 1 + count\_node(node.left) +
        count\_node(node.right)로 구성된다.

    -   즉 자신 노드 1과 양측의 서브트리의 노드 개수를 구한다.

<!-- -->

-   이후 노드의 갯수를 구하기 위하여 root를 인자로 받는 self.cal\_height
    메소드를 운용한다.

<!-- -->

-   만약 root가 비어있다면 더 이상 내려갈 곳이 없음을 의미하므로
    0을 반환한다.

-   그렇지 않다면 재귀적으로 루트의 높이를 구한다.

    -   이는 1 + max(cal\_height(node.left) +
        cal\_height(node.right))로 구성된다.

    -   즉 자신의 레벨 1과 양측의 서브트리의 높이 중 큰 것을 더한다.

<!-- -->

-   48406개의 데이터가 있으므로 구성될 수 있는 최소 레벨은 16, 최대
    레벨은 48406이다.

<!-- -->

-   2\^15 (=32768) &lt; 48406 &lt; 2\^16 (=65536)

<!-- -->

-   형성된 트리의 레벨은 37이므로 최악의 경우는 아니지만 최소 레벨까지
    개선할 수 있는 여지가 존재한다.

-   10개의 단어를 탐색하기 전, 후의 시간을 측정하여
    소요시간을 측정하였다.

-   모든 단어와 레벨이 정상적으로 출력되었다.

**5) B트리 생성**

-   균형이진탐색트리 – AVL트리

<!-- -->

-   앞서 구현한 트리의 경우 input 데이터에 의해 트리의 형태가 좌우된다.

-   만약 정렬된 input이 들어온다면, n개의 레벨 별로 1개의 노드를 가진
    편향트리가 만들어진다. 이 경우 탐색에 걸리는 시간은 O(N)이며, 이는
    이진탐색트리를 구성한 의미가 퇴색됨을 의미한다.

-   최선의 경우는 완전이진트리를 구성하는 것이다. 이 경우 탐색에 걸리는
    시간은 O(logN)이다. 그러므로 좌우의 균형을 갖춘 트리를
    구성해야 한다.

-   이를 해결하기 위하여 AVL트리를 구성하였다.

    -   AVL트리는 좌측과 우측 서브트리의 높이를 비교하여 서브트리의 차가
        1을 초과하는 비균형 상태라면 노드를 재배치함으로써
        균형을 맞춘다.

    -   그러므로 삽입 시 불균형 상태가 발생한다면, 조상노드부터 내려오는
        서브트리를 회전한다.

<!-- -->

-   이를 위해 기존의 BinarySearchTree 클래스에 AVL트리 관련
    메소드를 추가하였다.

<!-- -->

-   이진트리는 가장 상위 레벨의 노드를 가리키는 root 변수를 운용한다.

-   해당 클래스에 추가된 method에 대한 ADT는 다음과 같다.

> def rotateLL (self, node):\
> \# 단순회전: 시계 방향으로 회전
>
> def rotateRR(self, node):\
> \# 단순회전 : 반시계 방향으로 회전
>
> def rotateLR (self, node):\
> \# 이중회전 : LL회전 후 RR회전
>
> def rotateRL (self, node):\
> \# 이중회전 : RR회전 후 LR회전
>
> def get\_balance\_factor (self, node):\
> \# 서브트리의 높이를 비교한다.
>
> def rebalance(self, node):\
> \# 서브트리의 높이에 따라 균형을 맞춘다.
>
> def insert\_avl(self, word, meaning):\
> \# 삽입하고자 하는 단어와 뜻을 입력받아 트리가 구성되지 않았으면
> root에
>
> 삽입하고, 그렇지 않으면 \_\_insert\_node\_avl을 호출하여 그 값을
> 삽입한다.
>
> def \_\_insert\_node\_avl(self, cur, word, meaning):
>
> \# 현재 노드와 단어, 뜻을 입력받아 적절한 위치에 노드를 삽입한다.

-   데이터 파싱(main)

<!-- -->

-   A트리 생성과 마찬가지로 txt 파일에서 한줄씩 읽어 split을 통해 단어와
    뜻을 분리한다.

<!-- -->

-   트리 생성(self.insert)

<!-- -->

-   BinarySearchTree인스턴스를 생성하고, 단어와 뜻을 인자로 하여
    insert\_avl 메소드를 호출한다.

-   첫번째 단어의 경우 root노드에 삽입된다.

-   이후의 경우 기존 인자에 root노드를 더해 \_\_insert\_node\_avl
    메소드를 호출한다.

<!-- -->

-   트리 생성(self.\_\_insert\_\_node\_avl)

<!-- -->

-   BinarySearchTree인스턴스를 생성하고, 단어와 뜻을 인자로 하여
    insert\_avl 메소드를 호출한다.

-   첫번째 단어의 경우 root노드에 삽입된다.

-   이후의 경우 기존 인자에 root노드를 더해 \_\_insert\_node\_avl
    메소드를 호출한다.

    -   이는 A트리 생성과 동일한 로직으로 진행된다.

    -   차이점은 하나의 노드를 추가하고 rebalnce 메소드를 추가하여
        트리의 균형을 수행한다는 점이다.

<!-- -->

-   트리의 균형 맞추기(self.rebalance)

<!-- -->

-   균형을 맞추는 작업은 우선 왼쪽 서브트리와 오른쪽 서브트리의 높이
    차인 balance factor를 구하는 것에서 시작한다. 이를 위해
    get\_balance\_factor 메소드를 호출한다.

-   균형이 맞추어진 트리의 balance factor -1, 0, 1로 구성된다.

> ![](media/image5.png){width="5.128712817147856in"
> height="1.4914206036745408in"}

-   이 외의 경우는 균형이 깨졌다고 판단할 수 있으며 방향에 따라 크게
    4가지의 imbalanced tree가 존재한다.

    -   balance factor가 1보다 클 때 좌측 서브트리의 balance factor가
        0보다 크면 LL연산을, 그렇지 않다면 LR연산을 수행한다.

    -   balance factor가 1보다 작을 때 좌측 서브트리의 balance factor가
        0보다 작으면 RR연산을, 그렇지 않다면 RL연산을 수행한다.

    -   이와 관련한 사항은 하단에서 설명한다.

<!-- -->

-   불균형 트리의 종류와 해결1 – 단순회전 (rotate LL, rotateRR)

<!-- -->

-   Left Left imbalance : 왼쪽과 왼쪽으로 이루어진 불균형 트리를
    말 한다.

> ![](media/image6.png){width="1.8350043744531934in"
> height="1.693069772528434in"}![](media/image7.png){width="1.9665080927384078in"
> height="1.784689413823272in"}

-   RotateLL : 이를 해결하기 위해 트리를 시계방향으로 회전을 하는
    연산을 수행한다. 두번째 사례의 경우 C는 B의 오른쪽에 자식이며, 이는
    D보다 작으므로 D의 왼쪽 서브트리가 된다.

> ![](media/image8.png){width="1.9331780402449694in"
> height="1.5148512685914262in"}
> ![](media/image9.png){width="1.5540507436570428in"
> height="1.6077930883639544in"}

-   이를 코드로 구현하면, 노드의 왼쪽 자식을 새로운 노드에 저장 후, 기존
    노드의 왼쪽을 새 노드의 오른쪽 노드로 지정한다. 이후 새 노드의
    오른쪽을 기존 노드로 저장한다.

-   첫번째 사례를 예시로 들면, (B)를 새노드로 한 후, C의 왼쪽인 B의
    오른쪽이 없으므로 None으로 바꾸어 일종의 삭제를 한다. 이후 B의
    오른쪽 노드를 C로 지정한다.

<!-- -->

-   Right Right imbalance : 오른쪽과 오른쪽으로 이루어진 불균형 트리를
    말 한다.

> ![](media/image10.png){width="2.100786307961505in"
> height="2.20792104111986in"}![](media/image11.png){width="1.9971587926509187in"
> height="2.099009186351706in"}

-   RotateRR : RotateLL과 방향에서 차이가 있고 로직은 동일하다.

> ![](media/image8.png){width="1.9331780402449694in"
> height="1.5148512685914262in"}
> ![](media/image12.png){width="1.673267716535433in"
> height="1.6055577427821521in"}

-   불균형 트리의 종류와 해결2 – 이중회전 (rotate LR, rotateRL)

<!-- -->

-   Left Right imbalance : 왼쪽과 오른쪽으로 이루어진 불균형 트리를
    말 한다.

> ![](media/image13.png){width="2.047985564304462in"
> height="2.118811242344707in"}

-   RotateLR : 이를 해결하기 위해 이중회전을 수행한다. 우선 왼쪽 자식
    노드에 대해 반시계방향으로 회전하는 RR회전 후 루트 노드에 대한
    LL회전을 수행한다.

> ![](media/image14.png){width="4.722772309711286in"
> height="1.8891087051618547in"}
>
> ![](media/image15.png){width="4.712870734908137in"
> height="1.885148731408574in"}

-   Right Left imbalance : 오른쪽과 왼쪽으로 이루어진 불균형 트리를
    말 한다.

> ![](media/image16.png){width="1.881188757655293in"
> height="2.35580927384077in"}

-   RotateRL : RotateLR과 방향에서 차이가 있고 로직은 동일하다.

> ![](media/image16.png){width="5.396038932633421in"
> height="2.1584153543307085in"}![](media/image17.png){width="5.495047025371829in"
> height="2.1980194663167105in"}

**4) B트리 출력 결과 및 비교**

> ![](media/image18.png){width="6.263888888888889in"
> height="1.9083333333333334in"}

-   사전 파일을 읽기 전, 후의 시간을 측정하여 소요시간을 측정하였다.

-   생성된 노드의 갯수가 txt파일 내의 단어 개수와 동일하다.

<!-- -->

-   형성된 트리의 레벨은 19이므로 최악의 경우는 아니지만 최소 레벨
    개수인 16에 근사하다.

-   10개의 단어를 탐색하기 전, 후의 시간을 측정하여
    소요시간을 측정하였다.

-   모든 단어와 레벨이 정상적으로 출력되었다.

  트리   트리 생성 소요시간   트리 전체 높이   단어 탐색 소요시간   단어별 평균 레벨
  ------ -------------------- ---------------- -------------------- ------------------
  A      0.506                37               0.000247             18.8
  B      1224.295             19               0.000185             14.1

-   비교 결과 하나의 데이터를 삽입할 때 마다 트리의 조정이 일어나게
    되므로 많은 연산이 일어나게 된다. 이에 생성 소요시간은 AVL 트리가
    현저히 느리다.

-   그럼에도 불구하고 트리 전체 높이는 최소 트리 높이인 16에 근사할 만큼
    많은 개선이 이루어졌으며, 단어 10개의 평균 레벨을 비교해보았을 때
    감소한 것을 볼 수 있다.

-   탐색 소요시간에 관해서 약 25%의 성능 개선이 일어났음을 볼 수 있다.

-   즉, AVL 트리는 한번 데이터를 생성하는데에는 오래걸리지만, 탐색에
    있어서는 균형 트리를 형성하므로, 어떠한 input 데이터에 대하여 O(log
    N)을 보장한다.
