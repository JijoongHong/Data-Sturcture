**2. 사전 탐색 트리**

> **1) 트리 구조**
>
> **2) A트리 생성**
>
> **3) A트리 탐색**
>
> **4) A트리 출력 결과**
>
> **5) B트리 생성**
>
> **6) B트리 출력 결과 및 비교**


# **2. 사전 탐색트리 만들기**

## **1) 트리 구조**

-   노드 class

<!-- -->

-   하나의 데이터를 의미하는 노드는 다음과 같은 구조로 이루어져 있다.

-   self.word : 영단어

-   self.meaning : 영단어의 뜻

-   self.left : 왼쪽 노드의 주소

-   self.right : 오른쪽 노드의 주소

<!-- -->

-   이진탐색트리(BinarySearchTree class)

<!-- -->

-   이진트리는 가장 상위 레벨의 노드를 가리키는 root 변수를 운용한다.

-   해당 클래스의 method에 대한 ADT는 다음과 같다.

> def search(self, word, level):\
> \# 찾고자 하는 단어와 레벨변수(초기값0) 인자로 받아 트리가 구성되지
> 않았으면
>
> 0을, 구성되었다면 \_\_search\_node를 호출하여 그 값을 반환한다.\
> \
> def \_\_search\_node(self, cur, word, level):
>
> \# 현재 노드와 찾고자 하는 단어, 레벨변수(초기값0)을 인자로 받아 해당
> 단어가
>
> 존재한다면 뜻을 찾아 반환한다.
>
> def insert(self, word, meaning):
>
> \# 삽입하고자 하는 단어와 뜻을 입력받아 트리가 구성되지 않았으면
> root에
>
> 삽입하고, 그렇지 않으면 \_\_insert\_node를 호출하여 그 값을 삽입한다.
>
> def \_\_insert\_node(self, cur, word, meaning):
>
> \# 현재 노드와 단어, 뜻을 입력받아 적절한 위치에 노드를 삽입한다.\
> \
> def count\_node(self, node):\
> \# 트리에 구성된 노드의 갯수를 반환한다.\
> \
> def cal\_height(self, node):
>
> \# 트리의 높이를 반환한다.

## **2) A트리 생성**

-   데이터 파싱(main)

<!-- -->

-   txt 파일에서 한줄씩 읽어 split을 통해 단어와 뜻을 분리한다.

<!-- -->

-   트리 생성(self.insert)

<!-- -->

-   BinarySearchTree인스턴스를 생성하고, 단어와 뜻을 인자로 하여 insert
    메소드를 호출한다.

-   첫번째 단어의 경우 root노드에 삽입된다.

-   이후의 경우 기존 인자에 root노드를 더해 \_\_insert\_node
    메소드를 호출한다.

    -   이진탐색트리의 경우 루트노드를 기준으로 좌측에는 루트노드보다
        작은 항목이, 우측에는 루트노드보다 큰 항목이 자리한다.

    -   이에 현재 기준노드와 단어를 비교한 후, 루트노드보다 작다면
        좌측으로, 크다면 우측으로 자리하게 된다.

    -   이 때 기준노드의 왼쪽 혹은 오른쪽이 비어있다면 단어와 뜻으로
        노드를 생성하고 해당 자리에 노드를 삽입한다.

    -   만약 기준노드의 왼쪽이 비어있지 않다면 기준노드의 왼쪽을 다시
        기준노드로, 기준 노드의 오른쪽이 비어있지 않다면 기준노드의
        오른쪽을 다시 기준노드로 하여 재귀적으로 호출한다.

    -   위 일련의 과정은 탐색의 과정과 유사하다. 해당 노드가 위치해야할
        곳을 지속적으로 찾아나가 빈 자리에 해당 노드를 삽입하는 것이다.

**3) A트리 탐색**

-   랜덤 데이터 생성

<!-- -->

-   txt파일에 대해 readlines( )로 전체 데이터를 리스트 형태로 불러온다.

-   0 \~ 사전 갯수-1 까지의 정수를 랜덤하게 뽑은 후, 해당 인덱스의
    데이터를 가져온다.

-   이를 split을 통해 좌측만 추출한 후 리스트에 추가한다.

    -   위의 일련의 과정을 list comprehension을 통해 다음과
        같이 표현하였다.

    -   random\_words = \[lines\[random.randint(0, count-1)\].split(" :
        ")\[0\] for \_ in range(10)\]

<!-- -->

-   탐색

<!-- -->

-   랜덤 생성된 단어를 하나씩 탐색하고 그 결과를 출력한다.

-   이를 위해 단어와 0(초기 level을 뜻하는 변수)를 인자로 하여
    search메소드를 호출한다.

    -   만약 루트노드가 비어있다면 None과 0을 튜플 형태로 반환한다.

    -   그렇지 않다면 루트노드를 현재 노드로 하여
        \_\_search\_node를 호출한다.

-   \_\_search\_node는 삽입연산과 마찬가지로 재귀적으로 호출된다. 이 때
    현재 노드를 의미하는 cur 변수와 레벨을 의미하는 level 변수를
    운용하게 된다.

-   만약 cur가 None이라면 말단의 리프노드까지 내려왔다는 것을 의미하므로
    더이상 찾을 것이 없어 None과 0을 튜플 형태로 반환한다.

-   만약 cur의 단어와 찾고자 하는 단어가 동일하다면 단어의 뜻과
    레벨을 반환한다.

-   만약 동일하지 않는다면 단어를 찾고자 자식 노드를 지속적으로
    탐색해야 한다.

    -   이진탐색트리는 루트노드를 기준으로 좌측에는 루트보다 작은 값이,
        우측에는 루트보다 큰 값이 존재한다.

    -   그러므로 루트노드와의 연산을 통해 좌측 또는 우측
        자식노드로 이동한다. 이 때 level변수를 1증가시켜 찾고자하는 값의
        레벨을 계산한다.

    -   이에 루트노드가 찾고자 하는 값보다 크다면 좌측 자식노드를 cur
        기준노드로 하여, 작다면 우측 자식노드를 cur 기준노드로 하여
        재귀적으로 호출한다.

## **4) A트리 출력 결과**

  ![image](https://user-images.githubusercontent.com/63644587/119697026-bff1ef00-be8a-11eb-9aac-e0b3f766c2b1.png)


-   사전 파일을 읽기 전, 후의 시간을 측정하여 소요시간을 측정하였다.

-   생성된 노드의 갯수가 txt파일 내의 단어 갯수와 동일하다.

<!-- -->

-   이를 위해 root를 인자로 받는 self.count\_node 메소드를 운용한다.

-   만약 root가 비어있다면 더 이상 내려갈 곳이 없음을 의미하므로
    0을 반환한다.

-   그렇지 않다면 재귀적으로 노드의 개수를 구한다.

    -   이는 1 + count\_node(node.left) +
        count\_node(node.right)로 구성된다.

    -   즉 자신 노드 1과 양측의 서브트리의 노드 개수를 구한다.

<!-- -->

-   이후 노드의 갯수를 구하기 위하여 root를 인자로 받는 self.cal\_height
    메소드를 운용한다.

<!-- -->

-   만약 root가 비어있다면 더 이상 내려갈 곳이 없음을 의미하므로
    0을 반환한다.

-   그렇지 않다면 재귀적으로 루트의 높이를 구한다.

    -   이는 1 + max(cal\_height(node.left) +
        cal\_height(node.right))로 구성된다.

    -   즉 자신의 레벨 1과 양측의 서브트리의 높이 중 큰 것을 더한다.

<!-- -->

-   48406개의 데이터가 있으므로 구성될 수 있는 최소 레벨은 16, 최대
    레벨은 48406이다.

<!-- -->

-   2\^15 (=32768) &lt; 48406 &lt; 2\^16 (=65536)

<!-- -->

-   형성된 트리의 레벨은 37이므로 최악의 경우는 아니지만 최소 레벨까지
    개선할 수 있는 여지가 존재한다.

-   10개의 단어를 탐색하기 전, 후의 시간을 측정하여
    소요시간을 측정하였다.

-   모든 단어와 레벨이 정상적으로 출력되었다.

## **5) B트리 생성**

-   균형이진탐색트리 – AVL트리

<!-- -->

-   앞서 구현한 트리의 경우 input 데이터에 의해 트리의 형태가 좌우된다.

-   만약 정렬된 input이 들어온다면, n개의 레벨 별로 1개의 노드를 가진
    편향트리가 만들어진다. 이 경우 탐색에 걸리는 시간은 O(N)이며, 이는
    이진탐색트리를 구성한 의미가 퇴색됨을 의미한다.

-   최선의 경우는 완전이진트리를 구성하는 것이다. 이 경우 탐색에 걸리는
    시간은 O(logN)이다. 그러므로 좌우의 균형을 갖춘 트리를
    구성해야 한다.

-   이를 해결하기 위하여 AVL트리를 구성하였다.

    -   AVL트리는 좌측과 우측 서브트리의 높이를 비교하여 서브트리의 차가
        1을 초과하는 비균형 상태라면 노드를 재배치함으로써
        균형을 맞춘다.

    -   그러므로 삽입 시 불균형 상태가 발생한다면, 조상노드부터 내려오는
        서브트리를 회전한다.

<!-- -->

-   이를 위해 기존의 BinarySearchTree 클래스에 AVL트리 관련
    메소드를 추가하였다.

<!-- -->

-   이진트리는 가장 상위 레벨의 노드를 가리키는 root 변수를 운용한다.

-   해당 클래스에 추가된 method에 대한 ADT는 다음과 같다.

> def rotateLL (self, node):\
> \# 단순회전: 시계 방향으로 회전
>
> def rotateRR(self, node):\
> \# 단순회전 : 반시계 방향으로 회전
>
> def rotateLR (self, node):\
> \# 이중회전 : LL회전 후 RR회전
>
> def rotateRL (self, node):\
> \# 이중회전 : RR회전 후 LR회전
>
> def get\_balance\_factor (self, node):\
> \# 서브트리의 높이를 비교한다.
>
> def rebalance(self, node):\
> \# 서브트리의 높이에 따라 균형을 맞춘다.
>
> def insert\_avl(self, word, meaning):\
> \# 삽입하고자 하는 단어와 뜻을 입력받아 트리가 구성되지 않았으면
> root에
>
> 삽입하고, 그렇지 않으면 \_\_insert\_node\_avl을 호출하여 그 값을
> 삽입한다.
>
> def \_\_insert\_node\_avl(self, cur, word, meaning):
>
> \# 현재 노드와 단어, 뜻을 입력받아 적절한 위치에 노드를 삽입한다.

-   데이터 파싱(main)

<!-- -->

-   A트리 생성과 마찬가지로 txt 파일에서 한줄씩 읽어 split을 통해 단어와
    뜻을 분리한다.

<!-- -->

-   트리 생성(self.insert)

<!-- -->

-   BinarySearchTree인스턴스를 생성하고, 단어와 뜻을 인자로 하여
    insert\_avl 메소드를 호출한다.

-   첫번째 단어의 경우 root노드에 삽입된다.

-   이후의 경우 기존 인자에 root노드를 더해 \_\_insert\_node\_avl
    메소드를 호출한다.

<!-- -->

-   트리 생성(self.\_\_insert\_\_node\_avl)

<!-- -->

-   BinarySearchTree인스턴스를 생성하고, 단어와 뜻을 인자로 하여
    insert\_avl 메소드를 호출한다.

-   첫번째 단어의 경우 root노드에 삽입된다.

-   이후의 경우 기존 인자에 root노드를 더해 \_\_insert\_node\_avl
    메소드를 호출한다.

    -   이는 A트리 생성과 동일한 로직으로 진행된다.

    -   차이점은 하나의 노드를 추가하고 rebalnce 메소드를 추가하여
        트리의 균형을 수행한다는 점이다.

<!-- -->

-   트리의 균형 맞추기(self.rebalance)

<!-- -->

-   균형을 맞추는 작업은 우선 왼쪽 서브트리와 오른쪽 서브트리의 높이
    차인 balance factor를 구하는 것에서 시작한다. 이를 위해
    get\_balance\_factor 메소드를 호출한다.

-   균형이 맞추어진 트리의 balance factor -1, 0, 1로 구성된다.

    ![image](https://user-images.githubusercontent.com/63644587/119697112-d39d5580-be8a-11eb-9f39-eb2ba61f103b.png)


-   이 외의 경우는 균형이 깨졌다고 판단할 수 있으며 방향에 따라 크게
    4가지의 imbalanced tree가 존재한다.

    -   balance factor가 1보다 클 때 좌측 서브트리의 balance factor가
        0보다 크면 LL연산을, 그렇지 않다면 LR연산을 수행한다.

    -   balance factor가 1보다 작을 때 좌측 서브트리의 balance factor가
        0보다 작으면 RR연산을, 그렇지 않다면 RL연산을 수행한다.

    -   이와 관련한 사항은 하단에서 설명한다.

<!-- -->

-   불균형 트리의 종류와 해결1 – 단순회전 (rotate LL, rotateRR)

<!-- -->

-   Left Left imbalance : 왼쪽과 왼쪽으로 이루어진 불균형 트리를
    말 한다.
    
    ![image](https://user-images.githubusercontent.com/63644587/119697147-dbf59080-be8a-11eb-878a-d0bd76d6b91a.png) ![image](https://user-images.githubusercontent.com/63644587/119697182-e2840800-be8a-11eb-925c-42a8ba04dbbe.png)


-   RotateLL : 이를 해결하기 위해 트리를 시계방향으로 회전을 하는
    연산을 수행한다. 두번째 사례의 경우 C는 B의 오른쪽에 자식이며, 이는
    D보다 작으므로 D의 왼쪽 서브트리가 된다.

    ![image](https://user-images.githubusercontent.com/63644587/119697200-e879e900-be8a-11eb-8f3e-ff9920574cbf.png) ![image](https://user-images.githubusercontent.com/63644587/119697209-eadc4300-be8a-11eb-90a7-227991665b15.png)



-   이를 코드로 구현하면, 노드의 왼쪽 자식을 새로운 노드에 저장 후, 기존
    노드의 왼쪽을 새 노드의 오른쪽 노드로 지정한다. 이후 새 노드의
    오른쪽을 기존 노드로 저장한다.

-   첫번째 사례를 예시로 들면, (B)를 새노드로 한 후, C의 왼쪽인 B의
    오른쪽이 없으므로 None으로 바꾸어 일종의 삭제를 한다. 이후 B의
    오른쪽 노드를 C로 지정한다.

<!-- -->

-   Right Right imbalance : 오른쪽과 오른쪽으로 이루어진 불균형 트리를
    말 한다.
    
    ![image](https://user-images.githubusercontent.com/63644587/119697224-f0d22400-be8a-11eb-84cf-0db98096021e.png) ![image](https://user-images.githubusercontent.com/63644587/119697236-f3347e00-be8a-11eb-95a3-3c6e7a85dd4c.png)



-   RotateRR : RotateLL과 방향에서 차이가 있고 로직은 동일하다.

    ![image](https://user-images.githubusercontent.com/63644587/119697253-f891c880-be8a-11eb-868f-269e5f26c320.png) ![image](https://user-images.githubusercontent.com/63644587/119697268-fcbde600-be8a-11eb-93e1-fac4868ae38a.png)


-   불균형 트리의 종류와 해결2 – 이중회전 (rotate LR, rotateRL)

<!-- -->

-   Left Right imbalance : 왼쪽과 오른쪽으로 이루어진 불균형 트리를
    말 한다.

    ![image](https://user-images.githubusercontent.com/63644587/119697307-05162100-be8b-11eb-9183-717bf17dd4a7.png)


-   RotateLR : 이를 해결하기 위해 이중회전을 수행한다. 우선 왼쪽 자식
    노드에 대해 반시계방향으로 회전하는 RR회전 후 루트 노드에 대한
    LL회전을 수행한다.
    
    ![image](https://user-images.githubusercontent.com/63644587/119697334-0c3d2f00-be8b-11eb-9e5b-a7daeae3a797.png)

    ![image](https://user-images.githubusercontent.com/63644587/119697354-10694c80-be8b-11eb-94a3-1589fcf8755f.png)

    

-   Right Left imbalance : 오른쪽과 왼쪽으로 이루어진 불균형 트리를
    말 한다.

    ![image](https://user-images.githubusercontent.com/63644587/119697373-15c69700-be8b-11eb-9ecd-bf8cfbdfd1a5.png)


-   RotateRL : RotateLR과 방향에서 차이가 있고 로직은 동일하다.
    
    ![image](https://user-images.githubusercontent.com/63644587/119697387-1b23e180-be8b-11eb-9df1-43949f92817f.png)
    
    ![image](https://user-images.githubusercontent.com/63644587/119697402-1e1ed200-be8b-11eb-9e33-d9c724569e26.png)




## **4) B트리 출력 결과 및 비교**
    
    ![image](https://user-images.githubusercontent.com/63644587/119697431-24ad4980-be8b-11eb-94a6-c7f4d2cb0da8.png)


-   사전 파일을 읽기 전, 후의 시간을 측정하여 소요시간을 측정하였다.

-   생성된 노드의 갯수가 txt파일 내의 단어 개수와 동일하다.

<!-- -->

-   형성된 트리의 레벨은 19이므로 최악의 경우는 아니지만 최소 레벨
    개수인 16에 근사하다.

-   10개의 단어를 탐색하기 전, 후의 시간을 측정하여
    소요시간을 측정하였다.

-   모든 단어와 레벨이 정상적으로 출력되었다.

  트리   트리 생성 소요시간   트리 전체 높이   단어 탐색 소요시간   단어별 평균 레벨
  ------ -------------------- ---------------- -------------------- ------------------
  A      0.506                37               0.000247             18.8
  B      1224.295             19               0.000185             14.1

-   비교 결과 하나의 데이터를 삽입할 때 마다 트리의 조정이 일어나게
    되므로 많은 연산이 일어나게 된다. 이에 생성 소요시간은 AVL 트리가
    현저히 느리다.

-   그럼에도 불구하고 트리 전체 높이는 최소 트리 높이인 16에 근사할 만큼
    많은 개선이 이루어졌으며, 단어 10개의 평균 레벨을 비교해보았을 때
    감소한 것을 볼 수 있다.

-   탐색 소요시간에 관해서 약 25%의 성능 개선이 일어났음을 볼 수 있다.

-   즉, AVL 트리는 한번 데이터를 생성하는데에는 오래걸리지만, 탐색에
    있어서는 균형 트리를 형성하므로, 어떠한 input 데이터에 대하여 O(log
    N)을 보장한다.
