# 하나의 연결리스트로 1만명의 데이터 필드별 정렬하기

![image](https://user-images.githubusercontent.com/63644587/117575604-86e11d00-b11d-11eb-8cef-78cdf83ade8d.png) ![image](https://user-images.githubusercontent.com/63644587/117575612-8f395800-b11d-11eb-8b9f-bdbccd7a7910.png)




## **2. 연결리스트 응용**

### **1) 연결리스트 구조**

### **2) 데이터 생성**

### **3) 데이터 저장**

### **3) 출력 결과**



# **2. 연결리스트 응용** 

## **1) 연결리스트 구조**

- 노드 class
  - 하나의 데이터를 의미하는 노드는 다음과 같은 구조로 이루어져 있다.
  - self.id : 학번
  - self.name : 이름
  - self.phone : 전화번호
  - self.next\_id : 다음 학번 노드의 주소
  - self.next\_name : 다음 이름 노드의 주소

- 연결리스트(Student class)
  - 연결리스트는 단방향으로 구성된 연결리스트를 활용하며, 두 개의 연결리스트를 구현하지 않고 하나의 연결리스트에서 두 갈래의 화살표를 활용한다. 하나의 연결리스트에서 정렬된 두 정보를 찾아갈 수 있도록 head\_id와 head\_name을 운용함과 동시에 노드의 갯수를 의미하는 size 변수를 운용한다.
  - 해당 클래스의 method에 대한 ADT는 다음과 같다.



## **2) 데이터 생성**

- 데이터의 생성
  - 중복이 없는 학번을 생성한 후 이에 대한 무작위 이름과 전화번호를 할당하는 방식으로 이루어진다. 이 때 이름과 전화번호는 중복이 가능하다.

- 학번 : student\_id\_list = random.sample(range(20130000, 20200000), 10000)
  - random 모듈의 sample 메소드를 활용하여 10000개의 학번을 생성한다.
  - 이는 주어진 범위 내에서 비복원 추출을 하는 것으로 20130000 ~ 20219999 사이에서 무작위로 size 만큼 추출하여 student\_id\_list에 저장한다.

- 이름 : name = "". join([random.choice(string.ascii\_lowercase) for \_ in range(len\_name)])
  - random 모듈의 choice 메소드를 활용한다. 
  - 이는 주어진 범위 내에서 1개를 선택하는 것으로 string 클래스의 ascii\_lowercase에서 소문자 한 개를 선택하도록 한다. 
  - 10자 이내의 이름을 생성해야 하므로 1~10 중 무작위 수를 생성하여 len\_name에 저장한다.
  - 이와 같은 과정을 list comprehension을 통해 len\_name 만큼 반복하고 하나의 리스트에 넣는다. 
  - 이후 join 메소드를 통해 리스트 내부의 element를 문자열로 합쳐 반환토록 한다.

- 전화번호 : phone\_number = "010" + "".join([str(random.randint(0, 9)) for \_ in range(8)])
  - random 모듈의 randint 메소드를 활용한다. 
  - 이는 주어진 정수범위 내에서 1개를 추출하는 것으로 0~9범위에서 진행한다. 
  - 이름과 동일하게 전화번호 뒷부분에 해당하는 8자리 숫자를 생성한다. 
  - 다만 join 메소드의 인자의 형은 문자형태이므로 타입 캐스팅을 통해 정수형을 문자열로 변경한다. 
  - 이렇게 생성된 8자리 숫자와 010을 합친다. 




## **3) 데이터 저장**

- 학번 기준 정렬
  - where\_to\_insert\_id 메소드를 활용하여 학번 기준으로 삽입할 곳을 탐색한다.
    - 시작위치를 head\_id로 하여 가장 빠른 학번부터 탐색하여 추가할 노드보다 더 큰 노드를 만나면 그 위치를 반환한다.
    - 만약 마지막 노드까지 탐색하였다면 맨 마지막에 추가해야므로 마지막 노드 위치를 반환한다.
  - Insert\_id 메소드를 활용하여 학번 기준으로 노드를 삽입한다.
    - get\_node\_id 메소드로 추가할 곳의 이전 노드 위치를 확인한다.
    - 인자로 받은 학번, 이름, 전화번호로 새로운 노드를 생성한다.
    - 만약 이전 노드가 없다면 맨 앞에 추가해야하므로 새로 추가한 노드가 현재 맨 앞 노드의 위치를 가리키도록 하는 한편, head\_id가 새로 추가한 노드를 가리키도록 한다.
    - 이 외에는 새로 추가한 노드가 다음 노드의 위치를 가리키도록 하고, 이전 노드의 위치를 새로 추가한 노드가 가리키도록 한다. 
    - 이후 새로 추가한 노드의 주소를 반환한다.

- 이름 기준 정렬
  - where\_to\_insert\_name 메소드를 활용하여 이름 기준으로 삽입할 곳을 탐색한다.
    - 시작위치를 head\_name으로 하여 가장 빠른 이름부터 탐색하여 추가할 노드보다 더 큰 노드를 만나면 그 위치를 반환한다.
    - 만약 마지막 노드까지 탐색하였다면 맨 마지막에 추가해야므로 마지막 노드 위치를 반환한다.
  - Insert\_name 메소드를 활용하여 학번 기준으로 노드를 연결한다.
    - get\_node\_name 메소드로 추가할 곳의 이전 노드 위치를 확인한다.
    - 인자로 이미 생성된 노드를 받아 이를 활용한다.
    - 만약 이전 노드가 없다면 맨 앞에 연결해야하므로 새로 추가하는 노드가 현재 맨 앞 노드의 위치를 가리키도록 하는 한편, head\_name이 새로 추가한 노드를 가리키도록 한다.
    - 이 외에는 새로 추가한 노드가 다음 노드의 위치를 가리키도록 하고, 이전 노드의 위치를 새로 추가한 노드가 가리키도록 한다. 

- 위 과정을 거쳐 하나의 연결리스트에서 정렬된 두 가지 경로를 유지할 수 있게 된다.

  <img width="1150" alt="스크린샷 2021-05-09 오후 11 26 28" src="https://user-images.githubusercontent.com/63644587/117575700-fc4ced80-b11d-11eb-9d3d-2e5eb51d47ac.png">


## **4) 출력**

- 입력받은 숫자에 따라 모드를 설정하고 display\_id( ) 혹은 display\_name( )을 호출한다. 
- 각 메소드는 head\_id 혹은 head\_name에서부터 마지막 노드까지 순회하며 정보를 출력한다.
- 이 때 100명씩 건너뛰며 출력해야하므로 모듈러 연산을 통해 출력할 인덱스를 결정한다.
- 학번순 출력 결과 정상적으로 출력되었다.


  ![image](https://user-images.githubusercontent.com/63644587/117575716-0e2e9080-b11e-11eb-8db9-1824a6adfae6.png) ![image](https://user-images.githubusercontent.com/63644587/117575722-12f34480-b11e-11eb-84bb-31601c7c8eb1.png)





- 이름순 출력 결과 정상적으로 출력되었다.

  ![image](https://user-images.githubusercontent.com/63644587/117575738-1e467000-b11e-11eb-86a2-cfe23b5e7765.png) ![image](https://user-images.githubusercontent.com/63644587/117575741-230b2400-b11e-11eb-833d-f5ca9465c249.png)


